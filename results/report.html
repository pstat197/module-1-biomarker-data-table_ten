<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Brooks Piper, Srinidhi Satish, Adarsh Nagar, Nicole Xu, Quinlan Wilson, Nini Yen">
<meta name="dcterms.date" content="2025-11-05">

<title>Biomarkers of ASD</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="report_files/libs/clipboard/clipboard.min.js"></script>
<script src="report_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="report_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="report_files/libs/quarto-html/popper.min.js"></script>
<script src="report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="report_files/libs/quarto-html/anchor.min.js"></script>
<link href="report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="report_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="report_files/libs/bootstrap/bootstrap-16bbabe37efa2ecafad14e96199f1a13.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script src="report_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="report_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="report_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Biomarkers of ASD</h1>
<p class="subtitle lead">PSTAT 197A Table 10</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Brooks Piper, Srinidhi Satish, Adarsh Nagar, Nicole Xu, Quinlan Wilson, Nini Yen </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Updated</div>
    <div class="quarto-title-meta-contents">
      <p class="date">November 5, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="abstract" class="level1">
<h1>Abstract</h1>
<p>This report looks at potential protein biomarkers linked to Autism Spectrum Disorder (ASD) using data from Hewitson et al.&nbsp;(2021). The dataset includes serum samples from 154 boys—76 with ASD and 78 typically developing (TD)—with measurements for 1,317 proteins. We recreated and extended parts of the original analysis by using t-tests, random forests, and correlations to find proteins that best separate the ASD and TD groups. Logistic regression models were then built to test how well these proteins could classify subjects. We also tested how changes in the number of top proteins, data splits, and selection methods affected results. The fuzzy intersection method performed best, reaching 0.871 accuracy and 0.954 ROC AUC. A simpler two-protein SVM model and a LASSO model with 46 proteins also showed strong results, suggesting that different modeling approaches can effectively identify useful biomarkers for ASD.</p>
</section>
<section id="dataset" class="level1">
<h1>Dataset</h1>
<p>This data set was derived from Hewitson et al.&nbsp;(2021), observing and measuring Serum samples from a populous of 154 individuals comprised of 76 boys with ASD and 78 typically developing (TD) boys all between the ages of 18 months to 8 years. While each sample should appropriately analyze 1,125 proteins (since 192 of the 1,317 failed quality control), the exact proteins were left unidentified in the published study yielding following analyses based on the whole populous (1,317).Here, the two primary variable measurements are Autism Diagnostic Observation Schedule Scores (ADOS) and patient-attributed protein levels.</p>
<p>Prior to statistical testing, minor augmentations and adjustments were made in the preprocessing phase. Here, ‘V1’ is rewritten as ‘name’, ‘V2’ is rewritten as ‘abbreviation’, and all NA-named proteins are dropped. As a means to further clean the data set, columns with NA’s are dropped to reduce sparsity, outliers are trimmed to reduce estimation-related abnormalities further in analysis, and protein levels are log transformed to standardize comparative data.</p>
</section>
<section id="summary-of-published-analysis" class="level1">
<h1>Summary of published analysis</h1>
<p>The original SOMAcan study done by Hewitson et at. Aimed to identify biomarkers associated with Autism Spectrum Disorder (ASD) from typically developing (TD) controls. To test methodological sensitivity to design choices several model variations were explored. First we repeated the entire protein-selection on a 80% training partition before evaluating the accuracy of the model on the remaining test set. We also increased the number of top predictive proteins considered by each selection method. As well as comparing hard intersections (proteins selected by all methods) to fuzzy intersections (proteins selected by mean rank across all methods). For all methods protein selection was through three methods, t-test, random forest, and correlation. The proteins that were chosen were then put through a logistic regression model where performance was evaluated using sensitivity, specificity, accuracy, and ROC AUC.</p>
<p>Results showed that methodological modifications impacted performance moderately. Increasing the number of top proteins beyond 10 slightly increased sensitivity without too much improvement in accuracy, with the best model using 15 proteins attaining an accuracy of 0.871. The fuzzy intersection model outperforms the hard intersection approach indicating that partially overlapping proteins are significant. Alternative modeling produced simpler and stronger models. A two protein SVM model achieved 0.774 accuracy which matches the in class results. While a lasso regularized mode got 0.839 accuracy using 46 proteins. All these findings suggest that creating/adding new and more complex features to the model improves its performance.</p>
<p>Training and Test Set Split:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
  A[Raw Protein Data] --&gt; B[Preprocessing: Log-Transform + Outlier Trimming]
  B --&gt; C[Outlier Analysis]
  C --&gt; D[Split Data: 80% Training / 20% Testing]
  D --&gt; E[Feature Selection: t-test, Random Forest, Correlation]
  E --&gt; F[Train Logistic Regression on Training Set]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Larger Number of Proteins:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
  A[Raw Protein Data] --&gt; B[Preprocessing: Log-Transform + Outlier Trimming]
  B --&gt; C[Feature Selection: t-test, Random Forest, Correlation]
  C --&gt; D[Select Top 10–40 Proteins]
  D --&gt; E[Hard Intersection of Selected Proteins]
  E --&gt; F[Train Logistic Regression Model]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Fuzzy Intersection:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
  A[Raw Protein Data] --&gt; B[Preprocessing: Log-Transform + Outlier Trimming]
  B --&gt; C[Feature Selection: t-test, Random Forest, Correlation]
  C --&gt; D[Combine Using Fuzzy Intersection]
  D --&gt; E[Train Logistic Regression Model]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>SVM with 2 Proteins:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
  A[Raw Protein Data] --&gt; B[Preprocessing: Log-Transform + Outlier Trimming]
  B --&gt; C[Select Two Proteins: RELT, DERM]
  C --&gt; D[Train Support Vector Machine Classifier]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>LASSO Regularization:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
  A[Raw Protein Data] --&gt; B[Preprocessing: Log-Transform + Outlier Trimming]
  B --&gt; C[LASSO Regularization on All Proteins]
  C --&gt; D[Select 46 Proteins]
  D --&gt; E[Adjust Classification Threshold to 0.3]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>=======</p>
<p>In the Hewitson et al.&nbsp;paper, the authors first trained a random forest model 1000 times, representing a protein’s importance in predicting ASD vs TD using the mean decrease in Gini Index. Each protein’s importance value was then averaged over the 1000 training runs, and then the top 10 proteins based on importance value were chosen for a prediction model. The authors then used a t-test approach to find the top 10 proteins with the most significant difference between the means of the ASD and TD groups. Finally they used a correlation approach to calculate each protein’s correlation with ADOS total scores (SA + RRB), as a measure of ASD severity. The top 10 proteins based on absolute correlation coefficients were selected as predictors.</p>
<p>After proteins were selected through each of these 3 methods, the researchers found 5 core proteins that were common to all 3 methods, leaving 13 additional proteins. They trained a baseline model using the 5 core proteins and then tested whether or not the addition of one or more of the 13 other proteins improved prediction power. This was done using a logistic regression model was used with datasets based upon the RF model, the t-test model and the correlation model, taking the subjects’ assigned group (ASD or TD) as output variables. They split the data 80:20 and then calculated the trained model’s AUC on the test dataset, which was repeated 1000 times. The researchers also investigated the possible confounding factors such as ethnicity, co-morbid conditions/clinical diagnoses, age, and medication use, by splitting the dataset into two groups for each of these factors and running t-tests.</p>
<p>The results were that they found a panel of 9 proteins: the core 5 of mitogen-activated protein kinase 14 (MAPK14), immunoglobulin D (IgD), dermatopontin (DERM), ephrin type-B receptor 2 (EPHB2), soluble urokinase-type plasminogen activator receptor (suPAR), and the additional receptor tyrosine kinase-like orphan receptor 1 [ROR1], platelet receptor Gl24 [GI24], eukaryotic translation initiation factor 4H [elF-4H], and arylsulfatase B [ARSB]. The model had an AUC = 0.860±0.064, with a sensitivity = 0.833±0.118, and specificity = 0.846±0.118</p>
</section>
<section id="findings" class="level1">
<h1>Findings</h1>
<section id="impact-of-preprocessing-and-outliers" class="level2">
<h2 class="anchored" data-anchor-id="impact-of-preprocessing-and-outliers">Impact of preprocessing and outliers</h2>
<p>Log transformations are standard practice for ensuring data meets parametric assumptions for a number of hypothesis tests and statistical models. And reasonably, we can assume that a log-transformation was utilized for this exact reason. To confirm this hypothesis, we randomly selected three proteins, plotting their histograms which revealed strong right skews. We then applied the log-transformation and repeated this process for the same proteins, which produced normal and symmetric histograms. As a result, these data can be used in inference without any concern for assumption violations.</p>
<p>Aside from non-normal, skewed data, outliers are also present. To investigate patterns within the TD and ASD groups, we utilized the 1.5 IQR rule for each of the proteins. We first examined the top ten subjects with the most outliers, revealing that those in the TD group made up 70%. To get a more holistic perspective, we transitioned into looking at an aggregated sum of all outliers across groups, revealing that ASD and TD had 3334 and 3476, respectively. These results highlight the fact that while outlying protein levels in TD present as more extreme, ASD counts are more consistent.</p>
</section>
<section id="methodological-variations" class="level2">
<h2 class="anchored" data-anchor-id="methodological-variations">Methodological variations</h2>
<p>a) Repeat the analysis but carry out the entire selection procedure on a training partition</p>
<p>In this segment, data was split 80% training set and 20% test set before the entire selection procedure, performing statistical analyses and logistic regression model-fitting on training data prior to a final comparison with the unused test set. Test evaluation metrics yielded the following:</p>
<ul>
<li><p>Sensitivity = 0.75</p></li>
<li><p>Specificity = 0.80</p></li>
<li><p>Accuracy ≈ 0.77</p></li>
<li><p>ROC AUC ≈ 0.87</p></li>
</ul>
<p>The inherent expectation of evaluating metrics on unseen data may have been leaning towards lower estimates in all areas, however the above results are more indicative of the model’s reasonably strong ability to identify true cases of both classes, differentiate between classes, and generate generally reliable predictions. Thus, while analysis was only carried out on a training partition, general accuracy in predictions on the test set remains high.</p>
<p>b) Choose a larger number (more than ten) of top predictive proteins using each selection method</p>
<p>To examine how panel size affects performance, we repeated the selection process using larger sets of top predictive proteins (10–40) based on both <em>t</em>-test and random forest importance scores. The intersection of these sets was used to fit logistic regression models, and performance was evaluated on a held-out 20% test partition.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Top Proteins</th>
<th>Sensitivity</th>
<th>Specificity</th>
<th>Accuracy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>10</td>
<td>0.733</td>
<td>0.812</td>
<td>0.774</td>
</tr>
<tr class="even">
<td>15</td>
<td>0.800</td>
<td>0.938</td>
<td>0.871</td>
</tr>
<tr class="odd">
<td>20</td>
<td>0.867</td>
<td>0.750</td>
<td>0.806</td>
</tr>
<tr class="even">
<td>25</td>
<td>0.933</td>
<td>0.750</td>
<td>0.839</td>
</tr>
<tr class="odd">
<td>30</td>
<td>0.933</td>
<td>0.750</td>
<td>0.839</td>
</tr>
<tr class="even">
<td>35</td>
<td>0.933</td>
<td>0.812</td>
<td>0.871</td>
</tr>
<tr class="odd">
<td>40</td>
<td>0.933</td>
<td>0.750</td>
<td>0.839</td>
</tr>
</tbody>
</table>
<p>Accuracy remained relatively stable across models, fluctuating between <strong>0.77 and 0.87</strong>, while sensitivity generally increased with more proteins. Notably, using 15 or 35 top proteins yielded the highest accuracy (0.871) with strong sensitivity and specificity balance. These results suggest that expanding the protein set can improve sensitivity to ASD cases, though gains beyond 15–20 proteins offer diminishing returns. Overall, the classifier’s performance remained comparable to the in-class analysis, indicating that the original panel size was already near optimal for this dataset.</p>
<p>c) Use a fuzzy intersection instead of a hard intersection to combine the sets of top predictive proteins across selection methods</p>
<p>The results show that the Fuzzy intersection model preforms better then the Hard intersection model. Yielding a sensitivity of 0.867, specificity of 0.875, accuracy of 0.871, and ROC AUC of 0.954 all of which are better than the hard intersection model. These values represent the fuzzy model being more balances and effective at distinguishing between ASD and TD subject without disproportionately favoring one group. The better performance is likely coming from its capacity to integrate partially overlapping information across selection methods(t-test, random forest, correlation test). By allowing proteins that appear in multiple but not all selection methods not risking dropping meaningful biomarkers that are emphasized by only some of the methods.</p>
</section>
<section id="improved-classifier" class="level2">
<h2 class="anchored" data-anchor-id="improved-classifier">Improved classifier</h2>
<p>The classifier from the in class example’s best performing accuracy was 0.774, taken from a panel of 5 proteins. In the analyses, we explored separate modifications to:</p>
<p>a) Find a simpler panel that achieves comparable accuracy.</p>
<p>The benchmarked accuracy from the class example is 0.774, so that is what this experiment expected to replicated. Using a function that creates combinations of 2 different proteins and feeds the data into a Support Vector Machine classifier, it is shown that a 2 protein panel that consists of RELT and DERM produce classification accuracy of 0.774, which is comparable to the in class example, which utilized a 5 protein panel and a logistic regression classifier.</p>
<p>b) Find an alternate panel that achieves better performing accuracy.</p>
<p>Instead of comparing the proteins from multiple testing and random forest, the alternative method used was lasso regularization directly on the entire dataset. After shrinking the unimportant protein coefficients to 0 by finding the lambda that minimizes the mean cross validated error, we are left with a panel of 46 proteins. Additionally, the default classification threshold was adjusted from 0.5 to 0.3. Therefore the improved classification accuracy with these changes is 0.839.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>